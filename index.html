<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ImpostorWho - ¿Quién es el impostor?</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Animaciones personalizadas */
        @keyframes bounceRed {
            0%, 100% { transform: scale(1); color: #dc2626; }
            25% { transform: scale(1.3); color: #ef4444; }
            50% { transform: scale(1.1); color: #f87171; }
            75% { transform: scale(1.2); color: #fca5a5; }
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.8; transform: scale(1.05); }
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        @keyframes slideIn {
            from { transform: translateX(-100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        @keyframes countdown {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        
        .impostor-bounce {
            animation: bounceRed 2s ease-in-out;
        }
        
        .pulse-effect {
            animation: pulse 2s infinite;
        }
        
        .fade-in {
            animation: fadeIn 0.5s ease-out;
        }
        
        .slide-in {
            animation: slideIn 0.5s ease-out;
        }
        
        .countdown-animation {
            animation: countdown 1s infinite;
        }
        
        .trophy-gold { color: #FFD700; text-shadow: 0 0 10px rgba(255, 215, 0, 0.5); }
        .trophy-silver { color: #C0C0C0; text-shadow: 0 0 8px rgba(192, 192, 192, 0.4); }
        .trophy-bronze { color: #CD7F32; text-shadow: 0 0 6px rgba(205, 127, 50, 0.3); }
        
        .rank-1 { background: linear-gradient(135deg, #FFD700, #FFED4E); border: 2px solid #FFD700; }
        .rank-2 { background: linear-gradient(135deg, #C0C0C0, #E0E0E0); border: 2px solid #C0C0C0; }
        .rank-3 { background: linear-gradient(135deg, #CD7F32, #E6B87F); border: 2px solid #CD7F32; }
        
        .glow { box-shadow: 0 0 15px rgba(59, 130, 246, 0.5); }
        
        .hidden-word {
            transition: all 0.3s ease;
        }
        
        .hidden-word.hidden {
            opacity: 0.3;
            filter: blur(5px);
            user-select: none;
        }
        
        .hidden-word.visible {
            opacity: 1;
            filter: blur(0);
        }
        
        .shake {
            animation: shake 0.5s ease-in-out;
        }
        
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }
        
        .blink {
            animation: blink 1s infinite;
        }
        
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        @keyframes slideUp {
            from { transform: translateY(100%); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        
        .slide-up {
            animation: slideUp 0.3s ease-out;
        }
    </style>
</head>
<body>
    <!-- Audio elements -->
    <audio id="turnSound" preload="auto">
        <source src="https://assets.mixkit.co/sfx/preview/mixkit-game-show-wrong-answer-buzz-950.mp3" type="audio/mpeg">
    </audio>
    <audio id="timeWarningSound" preload="auto">
        <source src="https://assets.mixkit.co/sfx/preview/mixkit-unlock-game-notification-253.mp3" type="audio/mpeg">
    </audio>
    <audio id="timeUpSound" preload="auto">
        <source src="https://assets.mixkit.co/sfx/preview/mixkit-warning-alarm-buzzer-1551.mp3" type="audio/mpeg">
    </audio>
    <audio id="newRoundSound" preload="auto">
        <source src="https://assets.mixkit.co/sfx/preview/mixkit-winning-chimes-2015.mp3" type="audio/mpeg">
    </audio>
    
    <div id="root"></div>
    
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script type="text/babel">
        const { useState, useEffect, useRef } = React;
        
        // Configuración de Firebase
        const firebaseConfig = {
            apiKey: "AIzaSyDCjW-hV99_kxEhdxJ_9_3R5NfZsW4WAq0",
            authDomain: "descubre-al-impostor.firebaseapp.com",
            databaseURL: "https://descubre-al-impostor-default-rtdb.firebaseio.com",
            projectId: "descubre-al-impostor",
            storageBucket: "descubre-al-impostor.firebasestorage.app",
            messagingSenderId: "178562891534",
            appId: "1:178562891534:web:55a777565884e4d459e15f"
        };
        
        firebase.initializeApp(firebaseConfig);
        const database = firebase.database();
        
        // Componente de iconos
        const Icon = ({ type, size = 20 }) => {
            const icons = {
                users: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M23 21v-2a4 4 0 0 0-3-3.87"/></svg>,
                crown: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M2 12l10-9 10 9M2 12v10h20V12"/></svg>,
                play: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><polygon points="5 3 19 12 5 21 5 3"/></svg>,
                home: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="m3 9 9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/></svg>,
                copy: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><rect x="9" y="9" width="13" height="13" rx="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg>,
                check: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><polyline points="20 6 9 17 4 12"/></svg>,
                bot: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><rect x="3" y="11" width="18" height="10" rx="2"/><circle cx="12" cy="5" r="2"/><path d="M12 7v4"/></svg>,
                vote: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M9 11l3 3L22 4M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"/></svg>,
                mic: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3zM19 10v2a7 7 0 0 1-14 0v-2"/></svg>,
                alert: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="12"/><line x1="12" y1="16" x2="12.01" y2="16"/></svg>,
                eye: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg>,
                eyeOff: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"/><line x1="1" y1="1" x2="23" y2="23"/></svg>,
                trophy: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M6 9H4.5a2.5 2.5 0 0 1 0-5H6"/><path d="M18 9h1.5a2.5 2.5 0 0 0 0-5H18"/><path d="M4 22h16"/><path d="M10 14.66V17c0 .55-.47.98-.97 1.21C7.85 18.75 7 20.24 7 22"/><path d="M14 14.66V17c0 .55.47.98.97 1.21C16.15 18.75 17 20.24 17 22"/><path d="M18 2H6v7a6 6 0 0 0 12 0V2Z"/></svg>,
                star: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"/></svg>,
                refresh: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"/><path d="M21 3v5h-5"/><path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"/><path d="M3 21v-5h5"/></svg>,
                clock: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>,
                volume: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"/></svg>
            };
            return icons[type] || null;
        };

        // BASE DE DATOS DE PALABRAS MEJORADA CON SINÓNIMOS Y DESCRIPCIONES
        const WORDS_DATABASE = {
            animales: {
                words: [
                    'perro', 'gato', 'elefante', 'león', 'tigre', 'panda', 'koala', 
                    'delfín', 'ballena', 'águila', 'oso', 'zorro', 'jirafa', 'cebra',
                    'cocodrilo', 'serpiente', 'pingüino', 'tortuga', 'rana', 'murciélago',
                    'ardilla', 'conejo', 'caballo', 'vaca', 'oveja', 'cerdo', 'gallina',
                    'pato', 'ganso', 'búho'
                ],
                clues: {
                    perro: ['ladra', 'mascota', 'canino', 'fiel', 'collar', 'hueso', 'peludo', 'guau'],
                    gato: ['maúlla', 'felino', 'ronronea', 'bigotes', 'independiente', 'araña', 'ratón'],
                    elefante: ['trompa', 'grande', 'memoria', 'colmillos', 'orejas grandes', 'sabana', 'pesado'],
                    león: ['melena', 'rey', 'ruge', 'felino', 'selva', 'carnívoro', 'manada'],
                    tigre: ['rayas', 'felino', 'naranja', 'selva', 'cazador', 'poderoso', 'sigiloso'],
                    panda: ['bambú', 'oso', 'blanco y negro', 'china', 'tranquilo', 'peludo', 'en peligro'],
                    koala: ['eucalipto', 'australia', 'oso', 'dormilón', 'arbóreo', 'marsupial', 'tierno'],
                    delfín: ['inteligente', 'marino', 'mamífero', 'salta', 'amistoso', 'oceano', 'sonar'],
                    ballena: ['grande', 'oceano', 'mamífero', 'canta', 'azul', 'espuma', 'migración'],
                    águila: ['vuela', 'rapaz', 'vista aguda', 'nido alto', 'pico ganchudo', 'símbolo', 'libertad'],
                    oso: ['hiberna', 'peludo', 'grande', 'miel', 'garras', 'bosque', 'pardo'],
                    zorro: ['astuto', 'rojo', 'cola esponjosa', 'nocturno', 'ladrón', 'bosque', 'sigiloso']
                }
            },
            comida: {
                words: [
                    'pizza', 'hamburguesa', 'sushi', 'tacos', 'pasta', 'helado', 'ensalada',
                    'sandwich', 'paella', 'ramen', 'lasaña', 'burrito', 'quesadilla', 'tortilla',
                    'guacamole', 'chocolate', 'galletas', 'pastel', 'pan', 'arroz', 'pollo',
                    'pescado', 'carne', 'verduras', 'frutas', 'sopa', 'cereal', 'yogur', 'queso'
                ],
                clues: {
                    pizza: ['italiana', 'queso', 'pepperoni', 'masa', 'horno', 'redonda', 'corteza', 'delivery'],
                    hamburguesa: ['pan', 'carne', 'queso', 'lechuga', 'tomate', 'rápida', 'comida rápida', 'bbq'],
                    sushi: ['japonés', 'arroz', 'pescado', 'crudo', 'alga', 'wasabi', 'soja', 'rollo'],
                    tacos: ['mexicano', 'tortilla', 'carne', 'cilantro', 'cebolla', 'picante', 'limón', 'salsa'],
                    pasta: ['italiana', 'espagueti', 'fideos', 'salsa', 'tomate', 'albóndigas', 'parmesano', 'hervir'],
                    helado: ['frío', 'dulce', 'cono', 'cremoso', 'sabores', 'verano', 'postre', 'chocolate'],
                    ensalada: ['verduras', 'lechuga', 'tomate', 'pepino', 'saludable', 'fresco', 'vinagreta', 'ligero'],
                    sandwich: ['pan', 'jamón', 'queso', 'tostado', 'fácil', 'almuerzo', 'mayonesa', 'variedades']
                }
            },
            objetos: {
                words: [
                    'teléfono', 'computadora', 'reloj', 'llave', 'libro', 'guitarra', 'pelota',
                    'silla', 'lámpara', 'teclado', 'mouse', 'monitor', 'mesa', 'cama', 'sofá',
                    'espejo', 'cuchara', 'tenedor', 'cuchillo', 'plato', 'vaso', 'copa', 'cámara',
                    'radio', 'televisor', 'ventilador', 'refrigerador', 'horno', 'microondas', 'licuadora'
                ],
                clues: {
                    teléfono: ['llamar', 'móvil', 'pantalla', 'apps', 'mensajes', 'whatsapp', 'smartphone', 'contactos'],
                    computadora: ['teclado', 'pantalla', 'internet', 'trabajar', 'jugar', 'programar', 'archivos', 'software'],
                    reloj: ['hora', 'muñeca', 'digital', 'analógico', 'alarma', 'cronómetro', 'pulsera', 'tiempo'],
                    llave: ['abrir', 'cerradura', 'puerta', 'casa', 'coche', 'metal', 'enganchar', 'seguridad'],
                    libro: ['leer', 'páginas', 'historia', 'autor', 'biblioteca', 'conocimiento', 'novela', 'educación'],
                    guitarra: ['música', 'cuerdas', 'tocar', 'acordes', 'eléctrica', 'acústica', 'concierto', 'rock'],
                    pelota: ['jugar', 'redonda', 'deporte', 'fútbol', 'baloncesto', 'rebotar', 'equipo', 'gol']
                }
            },
            lugares: {
                words: [
                    'playa', 'montaña', 'ciudad', 'bosque', 'desierto', 'museo', 'parque',
                    'restaurante', 'aeropuerto', 'hospital', 'escuela', 'universidad', 'biblioteca',
                    'supermercado', 'centro comercial', 'cine', 'teatro', 'estadio', 'iglesia',
                    'hotel', 'banco', 'farmacia', 'estación', 'puerto', 'plaza', 'castillo',
                    'puente', 'túnel', 'volcán', 'isla'
                ],
                clues: {
                    playa: ['arena', 'mar', 'sol', 'olas', 'toalla', 'bronceado', 'vacaciones', 'concha'],
                    montaña: ['alto', 'escalar', 'nieve', 'cima', 'senderismo', 'vista', 'aventura', 'oxígeno'],
                    ciudad: ['edificios', 'tráfico', 'gente', 'calles', 'ruido', 'oportunidades', 'metro', 'urbano'],
                    bosque: ['árboles', 'naturaleza', 'animales', 'senderos', 'oxígeno', 'tranquilo', 'hojas', 'setas'],
                    desierto: ['arena', 'calor', 'cactus', 'seco', 'dunas', 'camello', 'oasis', 'extremo'],
                    museo: ['arte', 'historia', 'cuadros', 'exhibiciones', 'cultura', 'aprender', 'antigüedades', 'turistas'],
                    parque: ['jardín', 'bancos', 'fuente', 'paseo', 'familia', 'juegos', 'tranquilo', 'verde']
                }
            },
            colores: {
                words: [
                    'rojo', 'azul', 'verde', 'amarillo', 'morado', 'naranja', 'rosa',
                    'negro', 'blanco', 'gris', 'marrón', 'celeste', 'turquesa', 'violeta',
                    'dorado', 'plateado', 'beige', 'ocre', 'índigo', 'magenta', 'cian',
                    'esmeralda', 'rubí', 'zafiro', 'ámbar', 'ambar', 'carmesí', 'lavanda', 'menta'
                ],
                clues: {
                    rojo: ['sangre', 'amor', 'fuego', 'pasión', 'peligro', 'tomate', 'manzana', 'rosas'],
                    azul: ['cielo', 'mar', 'tranquilo', 'frío', 'confianza', 'agua', 'océano', 'jeans'],
                    verde: ['naturaleza', 'hojas', 'esperanza', 'primavera', 'hierba', 'ecológico', 'bosque', 'manzana'],
                    amarillo: ['sol', 'felicidad', 'limón', 'energía', 'girasol', 'oro', 'alegría', 'plátano'],
                    morado: ['reyes', 'misterio', 'uva', 'lavanda', 'creatividad', 'magia', 'elegancia', 'berenjena'],
                    naranja: ['fruta', 'energía', 'creatividad', 'zorro', 'puesta de sol', 'calabaza', 'jugo', 'alerta'],
                    rosa: ['dulce', 'amor', 'flores', 'femenino', 'algodón de azúcar', 'suave', 'ternura', 'bebé']
                }
            },
            musica: {
                words: [
                    'guitarra', 'piano', 'batería', 'violín', 'trompeta', 'flauta', 'saxofón',
                    'arpa', 'bajo', 'micrófono', 'teclado', 'acordeón', 'banjo', 'chelo',
                    'contrabajo', 'clarinete', 'oboe', 'trombón', 'tuba', 'timbales', 'maracas',
                    'güiro', 'castañuelas', 'triángulo', 'xilófono', 'armónica', 'ukelele', 'mandolina'
                ],
                clues: {
                    guitarra: ['cuerdas', 'rock', 'acordes', 'eléctrica', 'solista', 'músico', 'banda', 'melodía'],
                    piano: ['teclas', 'clásico', 'acordes', 'grande', 'música', 'instrumento', 'orquesta', 'sonata'],
                    batería: ['percusión', 'tambores', 'ritmo', 'platillos', 'golpes', 'energía', 'concierto', 'beat'],
                    violín: ['cuerda', 'clásico', 'arco', 'orquesta', 'agudo', 'melodía', 'concertino', 'virtuoso'],
                    trompeta: ['viento', 'metal', 'sonido fuerte', 'jazz', 'melodía', 'fanfarria', 'brass', 'solo'],
                    flauta: ['viento', 'madera', 'suave', 'melodía', 'clásica', 'aire', 'dulce', 'orquesta'],
                    saxofón: ['jazz', 'viento', 'metal', 'suave', 'melodía', 'improvisación', 'cool', 'nightclub']
                }
            },
            juegos: {
                words: [
                    'minecraft', 'fortnite', 'valorant', 'league of legends', 'counter strike', 'gta',
                    'zelda', 'pokemon', 'mario', 'sonic', 'call of duty', 'fifa', 'among us',
                    'roblox', 'overwatch', 'dota', 'world of warcraft', 'skyrim', 'fallout',
                    'assassins creed', 'resident evil', 'god of war', 'horizon', 'spider-man',
                    'uncharted', 'the last of us', 'red dead redemption', 'cyberpunk', 'elden ring'
                ],
                clues: {
                    minecraft: ['bloques', 'construir', 'crafteo', 'creeper', 'minar', 'survival', 'pixelado', 'mods'],
                    fortnite: ['battle royale', 'construir', 'baile', 'skin', 'temporada', 'victoria real', 'loot', 'escudo'],
                    valorant: ['disparos', 'agentes', 'habilidades', 'competitive', 'spike', 'eco', 'clutch', 'headshot'],
                    'league of legends': ['moba', 'campeones', 'nexo', 'torres', 'minions', 'ranked', 'pentakill', 'summoners rift'],
                    'counter strike': ['terroristas', 'antiterroristas', 'bomba', 'eco', 'awp', 'defuse', 'competitive', 'clutch'],
                    gta: ['coches', 'crímenes', 'mundo abierto', 'misión', 'arma', 'pandilla', 'dinero', 'libertad'],
                    pokemon: ['atrapar', 'entrenador', 'pokeball', 'evolución', 'batalla', 'pokedex', 'gimnasio', 'liga']
                }
            },
            variada: {
                words: [],
                clues: {}
            }
        };

        // Generar la categoría variada combinando todas las palabras
        WORDS_DATABASE.variada.words = [
            ...WORDS_DATABASE.animales.words,
            ...WORDS_DATABASE.comida.words,
            ...WORDS_DATABASE.objetos.words,
            ...WORDS_DATABASE.lugares.words,
            ...WORDS_DATABASE.colores.words,
            ...WORDS_DATABASE.musica.words,
            ...WORDS_DATABASE.juegos.words
        ].slice(0, 50); // Limitar a 50 palabras para variedad

        // Combinar todas las pistas
        WORDS_DATABASE.variada.clues = {
            ...WORDS_DATABASE.animales.clues,
            ...WORDS_DATABASE.comida.clues,
            ...WORDS_DATABASE.objetos.clues,
            ...WORDS_DATABASE.lugares.clues,
            ...WORDS_DATABASE.colores.clues,
            ...WORDS_DATABASE.musica.clues,
            ...WORDS_DATABASE.juegos.clues
        };

        const CATEGORY_HINTS = {
            animales: 'Animal',
            comida: 'Comida',
            objetos: 'Objeto',
            lugares: 'Lugar',
            colores: 'Color',
            musica: 'Música/Instrumento',
            juegos: 'Videojuego',
            variada: 'Palabra variada'
        };
        
        const BOT_NAMES = ['Alex', 'Sam', 'Taylor', 'Jordan', 'Riley', 'Casey'];
        
        // Componente principal del juego
        function ImpostorGame() {
            const [screen, setScreen] = useState('home');
            const [roomCode, setRoomCode] = useState('');
            const [playerName, setPlayerName] = useState('');
            const [currentPlayerId, setCurrentPlayerId] = useState(null);
            const [roomData, setRoomData] = useState(null);
            const [copied, setCopied] = useState(false);
            const [showInstructions, setShowInstructions] = useState(false);
            const [clueInput, setClueInput] = useState('');
            const [showWord, setShowWord] = useState(false);
            const [showImpostorAnimation, setShowImpostorAnimation] = useState(false);
            const [votingError, setVotingError] = useState('');
            const [roundTransition, setRoundTransition] = useState(false);
            const [transitionCountdown, setTransitionCountdown] = useState(5);
            const [soundEnabled, setSoundEnabled] = useState(true);
            const [notification, setNotification] = useState('');
            
            const wordRevealTimer = useRef(null);
            const impostorAnimationTimer = useRef(null);
            const playerTimerRef = useRef(null);
            const transitionTimerRef = useRef(null);
            const notificationTimerRef = useRef(null);
            const timeWarningPlayed = useRef(false);
            const timeUpPlayed = useRef(false);
            const turnSoundPlayed = useRef(false);
            
            const players = Object.values(roomData?.players || {});
            const isHost = roomData?.host === currentPlayerId;
            const gameStarted = roomData?.game?.started;
            const gamePhase = roomData?.game?.phase;
            const impostorIds = roomData?.game?.impostorIds || [];
            const isImpostor = impostorIds.includes(currentPlayerId);
            const topImpostors = roomData?.topImpostors || [];
            
            // Función para reproducir sonidos
            const playSound = (soundId) => {
                if (!soundEnabled) return;
                
                try {
                    const audio = document.getElementById(soundId);
                    if (audio) {
                        audio.currentTime = 0;
                        audio.play().catch(e => console.log("Error reproduciendo sonido:", e));
                    }
                } catch (error) {
                    console.log("Error con audio:", error);
                }
            };
            
            // Función para mostrar notificación temporal
            const showNotification = (message, duration = 3000) => {
                setNotification(message);
                if (notificationTimerRef.current) {
                    clearTimeout(notificationTimerRef.current);
                }
                notificationTimerRef.current = setTimeout(() => {
                    setNotification('');
                }, duration);
            };
            
            // Efecto para sonido de turno
            useEffect(() => {
                if (gameStarted && gamePhase === 'playing' && !roundTransition) {
                    const currentIndex = roomData?.game?.currentTurnIndex || 0;
                    const currentPlayer = players[currentIndex % players.length];
                    
                    if (currentPlayer?.id === currentPlayerId && !turnSoundPlayed.current) {
                        // Sonido para indicar que es tu turno
                        playSound('turnSound');
                        showNotification('¡Es tu turno! Escribe una pista', 2000);
                        turnSoundPlayed.current = true;
                    } else if (currentPlayer?.id !== currentPlayerId) {
                        // Resetear flag cuando no es nuestro turno
                        turnSoundPlayed.current = false;
                    }
                }
            }, [roomData?.game?.currentTurnIndex, gameStarted, gamePhase, currentPlayerId, players, roundTransition]);
            
            // Efecto para sonido de advertencia de tiempo
            useEffect(() => {
                if (gameStarted && gamePhase === 'playing' && !roundTransition) {
                    const timerValue = roomData?.game?.timer;
                    
                    if (timerValue !== null && timerValue !== undefined) {
                        // Sonido de advertencia cuando quedan 10 segundos
                        if (timerValue === 10 && !timeWarningPlayed.current) {
                            playSound('timeWarningSound');
                            showNotification('¡Quedan 10 segundos!', 1500);
                            timeWarningPlayed.current = true;
                        }
                        
                        // Sonido cuando se acaba el tiempo
                        if (timerValue === 0 && !timeUpPlayed.current) {
                            playSound('timeUpSound');
                            showNotification('¡Se acabó el tiempo!', 2000);
                            timeUpPlayed.current = true;
                        }
                        
                        // Resetear flags cuando el timer se reinicia
                        if (timerValue > 10) {
                            timeWarningPlayed.current = false;
                            timeUpPlayed.current = false;
                        }
                    }
                }
            }, [roomData?.game?.timer, gameStarted, gamePhase, roundTransition]);
            
            // Efecto para sonido de nueva ronda
            useEffect(() => {
                if (roundTransition && transitionCountdown === 5) {
                    playSound('newRoundSound');
                    showNotification(`¡Siguiente ronda en ${transitionCountdown} segundos!`, 2000);
                }
            }, [roundTransition, transitionCountdown]);
            
            // Efecto para animaciones al empezar el juego
            useEffect(() => {
                if (gameStarted && gamePhase === 'playing') {
                    // Limpiar timers anteriores
                    if (wordRevealTimer.current) clearTimeout(wordRevealTimer.current);
                    if (impostorAnimationTimer.current) clearTimeout(impostorAnimationTimer.current);
                    if (playerTimerRef.current) clearInterval(playerTimerRef.current);
                    
                    // Resetear flags de sonido
                    timeWarningPlayed.current = false;
                    timeUpPlayed.current = false;
                    turnSoundPlayed.current = false;
                    
                    // Mostrar palabra temporalmente para jugadores normales
                    if (!isImpostor) {
                        setShowWord(true);
                        wordRevealTimer.current = setTimeout(() => {
                            setShowWord(false);
                        }, 3000); // 3 segundos de visibilidad
                    }
                    
                    // Mostrar animación para impostores
                    if (isImpostor) {
                        setShowImpostorAnimation(true);
                        impostorAnimationTimer.current = setTimeout(() => {
                            setShowImpostorAnimation(false);
                        }, 2000); // 2 segundos de animación
                    }
                }
                
                return () => {
                    if (wordRevealTimer.current) clearTimeout(wordRevealTimer.current);
                    if (impostorAnimationTimer.current) clearTimeout(impostorAnimationTimer.current);
                    if (playerTimerRef.current) clearInterval(playerTimerRef.current);
                };
            }, [gameStarted, gamePhase, isImpostor]);
            
            // Efecto para transición entre rondas
            useEffect(() => {
                if (gameStarted && gamePhase === 'playing') {
                    const currentIndex = roomData?.game?.currentTurnIndex || 0;
                    const totalTurns = roomData?.game?.totalTurns || 0;
                    
                    // Verificar si es el último turno de la ronda
                    if (currentIndex > 0 && currentIndex % players.length === 0) {
                        const isLastPlayerOfRound = currentIndex === players.length * 3;
                        
                        if (isLastPlayerOfRound) {
                            // Iniciar transición de 5 segundos
                            setRoundTransition(true);
                            setTransitionCountdown(5);
                            
                            transitionTimerRef.current = setInterval(() => {
                                setTransitionCountdown(prev => {
                                    if (prev <= 1) {
                                        clearInterval(transitionTimerRef.current);
                                        setRoundTransition(false);
                                        return 0;
                                    }
                                    return prev - 1;
                                });
                            }, 1000);
                            
                            return () => {
                                if (transitionTimerRef.current) clearInterval(transitionTimerRef.current);
                            };
                        }
                    } else {
                        setRoundTransition(false);
                        setTransitionCountdown(5);
                    }
                }
            }, [roomData?.game?.currentTurnIndex, gameStarted, gamePhase, players.length]);
            
            // Escuchar cambios en la sala
            useEffect(() => {
                if (roomCode) {
                    const roomRef = database.ref(`rooms/${roomCode}`);
                    roomRef.on('value', (snapshot) => {
                        const data = snapshot.val();
                        setRoomData(data);
                        
                        // Limpiar error de votación cuando cambia la fase
                        if (data?.game?.phase !== 'voting') {
                            setVotingError('');
                        }
                    });
                    return () => roomRef.off();
                }
            }, [roomCode]);
            
            // Timer de jugador CORREGIDO - 30 segundos exactos
            useEffect(() => {
                if (gameStarted && gamePhase === 'playing' && !roundTransition) {
                    const currentIndex = roomData?.game?.currentTurnIndex || 0;
                    const currentPlayer = players[currentIndex % players.length];
                    const currentRound = Math.floor(currentIndex / players.length) + 1;
                    const hasResponded = roomData?.game?.responses?.[currentPlayer?.id]?.[currentRound];
                    
                    // Limpiar timer anterior
                    if (playerTimerRef.current) {
                        clearInterval(playerTimerRef.current);
                        playerTimerRef.current = null;
                    }
                    
                    // Solo activar timer para jugador actual que no sea bot y no haya respondido
                    if (currentPlayer && !currentPlayer.isBot && !hasResponded && currentPlayer.id === currentPlayerId) {
                        const startTime = Date.now();
                        const timeLimit = 30000; // 30 segundos exactos
                        let remainingSeconds = 30;
                        
                        // Establecer tiempo inicial
                        database.ref(`rooms/${roomCode}/game/timer`).set(remainingSeconds);
                        
                        playerTimerRef.current = setInterval(() => {
                            const elapsed = Date.now() - startTime;
                            remainingSeconds = Math.max(0, Math.floor((timeLimit - elapsed) / 1000));
                            
                            // Actualizar solo si cambió
                            database.ref(`rooms/${roomCode}/game/timer`).set(remainingSeconds);
                            
                            if (remainingSeconds === 0) {
                                clearInterval(playerTimerRef.current);
                                playerTimerRef.current = null;
                                
                                // Enviar respuesta automática
                                submitClue('(sin respuesta)');
                            }
                        }, 1000); // Actualizar cada segundo
                    } else {
                        // Limpiar timer si no es el turno del jugador
                        database.ref(`rooms/${roomCode}/game/timer`).set(null);
                    }
                }
                
                return () => {
                    if (playerTimerRef.current) {
                        clearInterval(playerTimerRef.current);
                        playerTimerRef.current = null;
                    }
                };
            }, [roomData?.game?.currentTurnIndex, gamePhase, players, roomData?.game?.responses, roomCode, currentPlayerId, gameStarted, roundTransition]);
            
            // Lógica para bots MEJORADA con pistas de sinónimos
            useEffect(() => {
                if (gameStarted && gamePhase === 'playing' && !roundTransition) {
                    const currentIndex = roomData?.game?.currentTurnIndex || 0;
                    const currentPlayer = players[currentIndex % players.length];
                    const currentRound = Math.floor(currentIndex / players.length) + 1;
                    
                    if (currentPlayer?.isBot) {
                        const hasResponded = roomData?.game?.responses?.[currentPlayer.id]?.[currentRound];
                        if (!hasResponded) {
                            const botTimeout = setTimeout(() => {
                                const impostorIds = roomData?.game?.impostorIds || [];
                                const isBotImpostor = impostorIds.includes(currentPlayer.id);
                                let clue;
                                
                                if (isBotImpostor) {
                                    // Para bots impostores: pistas genéricas según categoría
                                    const genericClues = {
                                        animales: ['vive', 'se mueve', 'criatura', 'ser', 'respira', 'animal', 'organismo'],
                                        comida: ['rico', 'se come', 'alimento', 'comestible', 'nutritivo', 'sabor', 'ingrediente'],
                                        objetos: ['útil', 'cosa', 'objeto', 'herramienta', 'material', 'instrumento', 'artefacto'],
                                        lugares: ['sitio', 'lugar', 'espacio', 'zona', 'ubicación', 'área', 'localización'],
                                        colores: ['tono', 'color', 'matiz', 'pigmento', 'tonalidad', 'sombra', 'tinte'],
                                        musica: ['suena', 'música', 'melodía', 'instrumento', 'ritmo', 'armonía', 'nota'],
                                        juegos: ['juego', 'entretenimiento', 'diversión', 'virtual', 'consola', 'videojuego', 'pasatiempo'],
                                        variada: ['algo', 'cosa', 'palabra', 'elemento', 'término', 'concepto', 'idea']
                                    };
                                    
                                    const category = roomData?.config?.category;
                                    const clues = genericClues[category] || ['cosa', 'objeto', 'elemento'];
                                    clue = clues[Math.floor(Math.random() * clues.length)];
                                } else {
                                    // Para bots normales: pistas específicas de la palabra
                                    const word = roomData?.game?.word;
                                    const category = roomData?.config?.category;
                                    const categoryData = WORDS_DATABASE[category];
                                    
                                    if (categoryData && categoryData.clues && categoryData.clues[word]) {
                                        // Usar pista específica de la palabra
                                        const specificClues = categoryData.clues[word];
                                        clue = specificClues[Math.floor(Math.random() * specificClues.length)];
                                    } else {
                                        // Pista genérica basada en la palabra
                                        clue = word?.charAt(0) + '...';
                                    }
                                }
                                
                                submitClue(clue);
                            }, 2000);
                            
                            return () => clearTimeout(botTimeout);
                        }
                    }
                }
                
                if (gamePhase === 'voting') {
                    const votes = roomData?.game?.votes || {};
                    const botPlayers = players.filter(p => p.isBot && !votes[p.id]);
                    
                    if (botPlayers.length > 0) {
                        const voteTimeout = setTimeout(() => {
                            botPlayers.forEach(bot => {
                                const otherPlayers = players.filter(p => p.id !== bot.id && !p.isBot);
                                const randomPlayer = otherPlayers.length > 0 
                                    ? otherPlayers[Math.floor(Math.random() * otherPlayers.length)]
                                    : players.filter(p => p.id !== bot.id)[0];
                                    
                                if (randomPlayer) {
                                    database.ref(`rooms/${roomCode}/game/votes/${bot.id}`).set(randomPlayer.id);
                                }
                            });
                        }, 2000);
                        
                        return () => clearTimeout(voteTimeout);
                    }
                }
            }, [roomData?.game?.currentTurnIndex, gamePhase, players, roomData?.game?.votes, roomData?.game?.responses, roomCode, roundTransition]);
            
            // Funciones principales
            const generateRoomCode = () => {
                return Math.random().toString(36).substring(2, 8).toUpperCase();
            };
            
            const createRoom = async () => {
                if (!playerName.trim()) return;
                
                const code = generateRoomCode();
                const playerId = Date.now().toString();
                
                await database.ref(`rooms/${code}`).set({
                    host: playerId,
                    players: {
                        [playerId]: {
                            id: playerId,
                            name: playerName,
                            isHost: true,
                            isBot: false,
                            joinedAt: Date.now()
                        }
                    },
                    config: {
                        category: '',
                        impostorCount: 1
                    },
                    game: {
                        started: false,
                        phase: 'lobby'
                    },
                    topImpostors: [],
                    roomStats: {
                        gamesPlayed: 0,
                        impostorWins: 0,
                        playerWins: 0
                    },
                    createdAt: Date.now()
                });
                
                setRoomCode(code);
                setCurrentPlayerId(playerId);
                setScreen('lobby');
            };
            
            const joinRoom = async () => {
                if (!playerName.trim() || !roomCode.trim()) return;
                
                try {
                    const snapshot = await database.ref(`rooms/${roomCode}`).once('value');
                    if (!snapshot.val()) {
                        alert('Sala no encontrada');
                        return;
                    }
                    
                    const playerId = Date.now().toString();
                    await database.ref(`rooms/${roomCode}/players/${playerId}`).set({
                        id: playerId,
                        name: playerName,
                        isHost: false,
                        isBot: false,
                        joinedAt: Date.now()
                    });
                    
                    setCurrentPlayerId(playerId);
                    setScreen('lobby');
                } catch (error) {
                    alert('Error: ' + error.message);
                }
            };
            
            const updateConfig = async (updates) => {
                await database.ref(`rooms/${roomCode}/config`).update(updates);
            };
            
            const addBot = async () => {
                const players = roomData?.players || {};
                const usedNames = new Set(Object.values(players).map(p => p.name));
                
                let botName;
                do {
                    botName = BOT_NAMES[Math.floor(Math.random() * BOT_NAMES.length)];
                } while (usedNames.has(`${botName} (Bot)`));
                
                const botId = `bot_${Date.now()}`;
                await database.ref(`rooms/${roomCode}/players/${botId}`).set({
                    id: botId,
                    name: `${botName} (Bot)`,
                    isHost: false,
                    isBot: true,
                    joinedAt: Date.now()
                });
            };
            
            const startGame = async () => {
                const players = Object.values(roomData?.players || {});
                
                if (players.length < 3) {
                    alert('Se necesitan al menos 3 jugadores');
                    return;
                }
                
                const category = roomData?.config?.category;
                if (!category) {
                    alert('Selecciona una categoría');
                    return;
                }
                
                const categoryData = WORDS_DATABASE[category];
                const word = categoryData.words[Math.floor(Math.random() * categoryData.words.length)];
                const shuffled = [...players].sort(() => Math.random() - 0.5);
                const impostorIds = shuffled.slice(0, roomData?.config?.impostorCount || 1).map(p => p.id);
                
                // Resetear estados de animación
                setShowWord(false);
                setShowImpostorAnimation(false);
                setRoundTransition(false);
                setTransitionCountdown(5);
                
                await database.ref(`rooms/${roomCode}/game`).update({
                    started: true,
                    phase: 'playing',
                    word,
                    impostorIds,
                    currentTurnIndex: 0,
                    totalTurns: players.length * 3,
                    responses: {},
                    votes: {},
                    timer: null,
                    startedAt: Date.now()
                });
            };
            
            const submitClue = async (clue) => {
                if (!clue.trim()) return;
                
                const players = Object.values(roomData?.players || {});
                const currentIndex = roomData?.game?.currentTurnIndex || 0;
                const currentPlayer = players[currentIndex % players.length];
                const currentRound = Math.floor(currentIndex / players.length) + 1;
                
                // Limpiar timer del jugador
                if (playerTimerRef.current) {
                    clearInterval(playerTimerRef.current);
                    playerTimerRef.current = null;
                }
                
                await database.ref(`rooms/${roomCode}/game/responses/${currentPlayer.id}/${currentRound}`).set({
                    round: currentRound,
                    clue,
                    timestamp: Date.now()
                });
                
                const nextIndex = currentIndex + 1;
                if (nextIndex >= (roomData?.game?.totalTurns || 0)) {
                    // Último turno - iniciar votación después de 5 segundos
                    setTimeout(() => {
                        database.ref(`rooms/${roomCode}/game`).update({
                            phase: 'voting',
                            currentTurnIndex: nextIndex
                        });
                    }, 5000);
                } else {
                    await database.ref(`rooms/${roomCode}/game`).update({
                        currentTurnIndex: nextIndex
                    });
                }
            };
            
            const submitVote = async (votedPlayerId) => {
                try {
                    await database.ref(`rooms/${roomCode}/game/votes/${currentPlayerId}`).set(votedPlayerId);
                } catch (error) {
                    console.error('Error al votar:', error);
                }
            };
            
            const finishVoting = async () => {
                try {
                    setVotingError('');
                    
                    // Verificar que todos hayan votado
                    const votes = roomData?.game?.votes || {};
                    const allVoted = Object.keys(votes).length === players.length;
                    
                    if (!allVoted) {
                        setVotingError('Esperando a que todos voten...');
                        return;
                    }
                    
                    const impostorIds = roomData?.game?.impostorIds || [];
                    const playersList = Object.values(roomData?.players || {});
                    
                    // Contar votos
                    const voteCounts = {};
                    Object.values(votes).forEach(vote => {
                        voteCounts[vote] = (voteCounts[vote] || 0) + 1;
                    });
                    
                    // Determinar el más votado y el segundo más votado
                    let voteResults = [];
                    if (Object.keys(voteCounts).length > 0) {
                        voteResults = Object.entries(voteCounts).sort((a, b) => b[1] - a[1]);
                    }
                    
                    const mostVoted = voteResults[0]; // [playerId, votes]
                    const secondMostVoted = voteResults[1]; // [playerId, votes] o undefined
                    
                    // NUEVA LÓGICA: El impostor gana solo si NO es el más votado
                    // O si tiene menos votos que otro jugador (empate favorable)
                    let impostorWon = false;
                    
                    if (mostVoted) {
                        const isImpostorMostVoted = impostorIds.includes(mostVoted[0]);
                        
                        if (!isImpostorMostVoted) {
                            // El impostor NO es el más votado → GANA
                            impostorWon = true;
                        } else if (secondMostVoted && mostVoted[1] === secondMostVoted[1]) {
                            // Empate entre el impostor y otro jugador
                            // El impostor tiene las mismas votos que otro → GANA (empate favorable)
                            impostorWon = true;
                        }
                        // Si el impostor es el más votado y tiene más votos que el segundo → PIERDE
                    }
                    
                    // Actualizar estadísticas
                    const currentStats = roomData?.roomStats || { gamesPlayed: 0, impostorWins: 0, playerWins: 0 };
                    const newStats = {
                        gamesPlayed: currentStats.gamesPlayed + 1,
                        impostorWins: impostorWon ? currentStats.impostorWins + 1 : currentStats.impostorWins,
                        playerWins: !impostorWon ? currentStats.playerWins + 1 : currentStats.playerWins
                    };
                    
                    // NUEVA LÓGICA PARA TOP 3: Solo impostores que ganaron suman puntos
                    let topImpostors = roomData?.topImpostors || [];
                    
                    // Agregar puntos solo a impostores que GANARON
                    if (impostorWon) {
                        impostorIds.forEach(impostorId => {
                            const impostor = playersList.find(p => p.id === impostorId);
                            if (impostor) {
                                const existingIndex = topImpostors.findIndex(item => item.id === impostorId);
                                
                                if (existingIndex >= 0) {
                                    // Actualizar impostor existente - +3 puntos por ganar
                                    topImpostors[existingIndex] = {
                                        ...topImpostors[existingIndex],
                                        points: topImpostors[existingIndex].points + 3,
                                        wins: topImpostors[existingIndex].wins + 1,
                                        games: topImpostors[existingIndex].games + 1,
                                        successfulGames: (topImpostors[existingIndex].successfulGames || 0) + 1
                                    };
                                } else {
                                    // Agregar nuevo impostor - 3 puntos por primera victoria
                                    topImpostors.push({
                                        id: impostorId,
                                        name: impostor.name,
                                        points: 3,
                                        wins: 1,
                                        games: 1,
                                        successfulGames: 1
                                    });
                                }
                            }
                        });
                    } else {
                        // Si el impostor perdió, solo suma 0 puntos pero cuenta el juego
                        impostorIds.forEach(impostorId => {
                            const impostor = playersList.find(p => p.id === impostorId);
                            if (impostor) {
                                const existingIndex = topImpostors.findIndex(item => item.id === impostorId);
                                
                                if (existingIndex >= 0) {
                                    // Actualizar impostor existente - 0 puntos por perder
                                    topImpostors[existingIndex] = {
                                        ...topImpostors[existingIndex],
                                        games: topImpostors[existingIndex].games + 1
                                        // No suma puntos ni victorias
                                    };
                                } else {
                                    // Agregar nuevo impostor - 0 puntos por primera derrota
                                    topImpostors.push({
                                        id: impostorId,
                                        name: impostor.name,
                                        points: 0,
                                        wins: 0,
                                        games: 1,
                                        successfulGames: 0
                                    });
                                }
                            }
                        });
                    }
                    
                    // Ordenar por puntos (descendente) y luego por porcentaje de victorias
                    topImpostors.sort((a, b) => {
                        if (b.points !== a.points) return b.points - a.points;
                        
                        // Calcular porcentaje de victorias
                        const aWinRate = a.games > 0 ? (a.wins / a.games) : 0;
                        const bWinRate = b.games > 0 ? (b.wins / b.games) : 0;
                        
                        return bWinRate - aWinRate;
                    });
                    
                    // Limitar a TOP 3
                    topImpostors = topImpostors.slice(0, 3);
                    
                    // Actualizar todo en Firebase
                    await database.ref(`rooms/${roomCode}`).update({
                        'game/phase': 'finished',
                        'game/winner': impostorWon ? 'impostors' : 'players',
                        'roomStats': newStats,
                        'topImpostors': topImpostors
                    });
                    
                } catch (error) {
                    console.error('Error al terminar votación:', error);
                    setVotingError('Error al procesar la votación: ' + error.message);
                }
            };
            
            const startNewGame = async () => {
                try {
                    // Resetear estados de animación
                    setShowWord(false);
                    setShowImpostorAnimation(false);
                    setRoundTransition(false);
                    setTransitionCountdown(5);
                    
                    await database.ref(`rooms/${roomCode}/game`).set({
                        started: false,
                        phase: 'lobby',
                        word: null,
                        impostorIds: null,
                        currentTurnIndex: 0,
                        responses: {},
                        votes: {},
                        timer: null,
                        winner: null,
                        startedAt: null
                    });
                } catch (error) {
                    console.error('Error al iniciar nueva partida:', error);
                }
            };
            
            const resetGame = async () => {
                try {
                    // Resetear estados de animación
                    setShowWord(false);
                    setShowImpostorAnimation(false);
                    setRoundTransition(false);
                    setTransitionCountdown(5);
                    
                    await database.ref(`rooms/${roomCode}`).update({
                        game: { 
                            started: false, 
                            phase: 'lobby',
                            word: null,
                            impostorIds: null,
                            currentTurnIndex: 0,
                            responses: {},
                            votes: {},
                            timer: null,
                            winner: null,
                            startedAt: null
                        },
                        topImpostors: [],
                        roomStats: { gamesPlayed: 0, impostorWins: 0, playerWins: 0 }
                    });
                } catch (error) {
                    console.error('Error al reiniciar juego:', error);
                }
            };
            
            const copyRoomCode = () => {
                navigator.clipboard.writeText(roomCode);
                setCopied(true);
                setTimeout(() => setCopied(false), 2000);
            };
            
            const goHome = async () => {
                try {
                    if (roomCode && currentPlayerId) {
                        await database.ref(`rooms/${roomCode}/players/${currentPlayerId}`).remove();
                    }
                } catch (error) {
                    console.error('Error al salir de la sala:', error);
                } finally {
                    setScreen('home');
                    setRoomCode('');
                    setPlayerName('');
                    setCurrentPlayerId(null);
                    setRoomData(null);
                    setShowWord(false);
                    setShowImpostorAnimation(false);
                    setVotingError('');
                    setRoundTransition(false);
                    setTransitionCountdown(5);
                    setNotification('');
                }
            };
            
            const toggleWordVisibility = () => {
                if (isImpostor) return;
                setShowWord(!showWord);
            };
            
            const toggleSound = () => {
                setSoundEnabled(!soundEnabled);
                showNotification(soundEnabled ? 'Sonido desactivado' : 'Sonido activado', 1500);
            };
            
            // Pantalla de inicio
            if (screen === 'home') {
                return (
                    <div className="min-h-screen bg-gradient-to-br from-purple-600 via-pink-500 to-red-500 flex items-center justify-center p-4">
                        <div className="bg-white rounded-3xl shadow-2xl p-8 max-w-md w-full">
                            <div className="text-center mb-8">
                                <h1 className="text-4xl font-bold text-gray-800 mb-2">ImpostorWho</h1>
                                <p className="text-gray-600">¿Quién es el impostor?</p>
                            </div>
                            
                            {showInstructions ? (
                                <div className="mb-6 p-4 bg-blue-50 rounded-xl text-sm space-y-2">
                                    <h3 className="font-bold text-blue-900 mb-2">📋 Cómo Jugar:</h3>
                                    <p><strong>1.</strong> Un jugador crea una sala y comparte el código</p>
                                    <p><strong>2.</strong> Todos se unen con el código de sala</p>
                                    <p><strong>3.</strong> El host elige categoría e inicia el juego</p>
                                    <p><strong>4.</strong> <span className="text-red-600 font-semibold">¡ATENCIÓN STREAMERS!</span> La palabra se oculta automáticamente</p>
                                    <p><strong>5.</strong> Por turnos dan pistas sobre su palabra</p>
                                    <p><strong>6.</strong> Al final, votan quién es el impostor</p>
                                    <p><strong>7.</strong> <span className="text-yellow-600 font-semibold">¡NUEVO!</span> TOP 3 impostores con mejor desempeño</p>
                                    <p><strong>8.</strong> <span className="text-green-600 font-semibold">¡SONIDOS!</span> Notificaciones auditivas para tu turno</p>
                                    <p className="text-red-600 font-semibold mt-3">🎯 Objetivo: Los jugadores deben encontrar al impostor</p>
                                    <button onClick={() => setShowInstructions(false)} className="w-full mt-3 bg-blue-500 text-white py-2 rounded-lg hover:bg-blue-600">
                                        Entendido
                                    </button>
                                </div>
                            ) : (
                                <button onClick={() => setShowInstructions(true)} className="w-full mb-4 bg-blue-100 text-blue-700 py-2 rounded-lg flex items-center justify-center gap-2 hover:bg-blue-200">
                                    <Icon type="alert" size={18} />
                                    ¿Cómo jugar?
                                </button>
                            )}
                            
                            <input 
                                type="text" 
                                placeholder="Tu nombre" 
                                value={playerName} 
                                onChange={(e) => setPlayerName(e.target.value)}
                                className="w-full px-4 py-3 border-2 border-gray-300 rounded-xl mb-4 focus:border-purple-500 focus:outline-none"
                            />
                            
                            <button 
                                onClick={createRoom} 
                                disabled={!playerName.trim()}
                                className="w-full bg-purple-600 hover:bg-purple-700 disabled:bg-gray-300 text-white font-semibold py-3 rounded-xl mb-3 transition"
                            >
                                Crear Sala
                            </button>
                            
                            <div className="relative my-6">
                                <div className="absolute inset-0 flex items-center">
                                    <div className="w-full border-t border-gray-300"></div>
                                </div>
                                <div className="relative flex justify-center text-sm">
                                    <span className="px-2 bg-white text-gray-500">o</span>
                                </div>
                            </div>
                            
                            <input 
                                type="text" 
                                placeholder="Código de sala" 
                                value={roomCode} 
                                onChange={(e) => setRoomCode(e.target.value.toUpperCase())}
                                className="w-full px-4 py-3 border-2 border-gray-300 rounded-xl mb-4 focus:border-pink-500 focus:outline-none"
                            />
                            
                            <button 
                                onClick={joinRoom} 
                                disabled={!playerName.trim() || !roomCode.trim()}
                                className="w-full bg-pink-500 hover:bg-pink-600 disabled:bg-gray-300 text-white font-semibold py-3 rounded-xl transition"
                            >
                                Unirse a Sala
                            </button>
                        </div>
                    </div>
                );
            }
            
            // Pantalla del lobby
            if (screen === 'lobby' && !gameStarted) {
                const roomStats = roomData?.roomStats || { gamesPlayed: 0, impostorWins: 0, playerWins: 0 };
                
                return (
                    <div className="min-h-screen bg-gradient-to-br from-blue-600 via-purple-500 to-pink-500 p-4">
                        <div className="max-w-4xl mx-auto">
                            <div className="bg-white rounded-3xl shadow-2xl p-8">
                                {/* Notificación flotante */}
                                {notification && (
                                    <div className="fixed top-4 right-4 bg-blue-500 text-white px-4 py-2 rounded-lg shadow-lg slide-up z-50">
                                        {notification}
                                    </div>
                                )}
                                
                                <div className="flex justify-between items-center mb-6">
                                    <h2 className="text-3xl font-bold text-gray-800">Sala de Espera</h2>
                                    <div className="flex items-center gap-2">
                                        <button 
                                            onClick={toggleSound}
                                            className={`p-2 rounded-lg transition ${soundEnabled ? 'bg-green-100 text-green-700' : 'bg-gray-100 text-gray-700'}`}
                                            title={soundEnabled ? 'Desactivar sonidos' : 'Activar sonidos'}
                                        >
                                            <Icon type="volume" size={20} />
                                        </button>
                                        <button onClick={goHome} className="p-2 hover:bg-gray-100 rounded-lg transition">
                                            <Icon type="home" size={24} />
                                        </button>
                                    </div>
                                </div>
                                
                                <div className="bg-gradient-to-r from-purple-100 to-pink-100 rounded-xl p-4 mb-6 flex items-center justify-between">
                                    <div>
                                        <p className="text-sm text-gray-600">Código de Sala</p>
                                        <p className="text-2xl font-bold text-purple-600">{roomCode}</p>
                                    </div>
                                    <button onClick={copyRoomCode} className="p-3 bg-white rounded-lg hover:bg-gray-50 transition">
                                        <Icon type={copied ? "check" : "copy"} size={24} />
                                    </button>
                                </div>
                                
                                {/* Estadísticas de la sala */}
                                {roomStats.gamesPlayed > 0 && (
                                    <div className="mb-6 bg-gradient-to-r from-green-50 to-blue-50 rounded-xl p-4 slide-in">
                                        <h3 className="text-lg font-semibold mb-2 flex items-center gap-2">
                                            <Icon type="trophy" size={20} />
                                            Estadísticas de la Sala
                                        </h3>
                                        <div className="grid grid-cols-3 gap-4">
                                            <div className="text-center">
                                                <p className="text-2xl font-bold text-blue-600">{roomStats.gamesPlayed}</p>
                                                <p className="text-sm text-gray-600">Partidas</p>
                                            </div>
                                            <div className="text-center">
                                                <p className="text-2xl font-bold text-green-600">{roomStats.playerWins}</p>
                                                <p className="text-sm text-gray-600">Ganó Jugadores</p>
                                            </div>
                                            <div className="text-center">
                                                <p className="text-2xl font-bold text-red-600">{roomStats.impostorWins}</p>
                                                <p className="text-sm text-gray-600">Ganó Impostor</p>
                                            </div>
                                        </div>
                                    </div>
                                )}
                                
                                {/* TOP 3 Impostores MEJORADO */}
                                {topImpostors.length > 0 && (
                                    <div className="mb-6 bg-gradient-to-r from-yellow-50 to-orange-50 rounded-xl p-4 fade-in">
                                        <h3 className="text-lg font-semibold mb-3 flex items-center gap-2">
                                            <Icon type="star" size={20} />
                                            TOP 3 Mejores Impostores
                                        </h3>
                                        <div className="space-y-3">
                                            {topImpostors.map((impostor, index) => {
                                                const winRate = impostor.games > 0 ? Math.round((impostor.wins / impostor.games) * 100) : 0;
                                                return (
                                                    <div key={impostor.id} className={`p-3 rounded-lg flex items-center justify-between ${index === 0 ? 'rank-1' : index === 1 ? 'rank-2' : 'rank-3'}`}>
                                                        <div className="flex items-center gap-3">
                                                            <span className={`text-2xl font-bold ${index === 0 ? 'trophy-gold' : index === 1 ? 'trophy-silver' : 'trophy-bronze'}`}>
                                                                {index === 0 ? '🥇' : index === 1 ? '🥈' : '🥉'}
                                                            </span>
                                                            <div>
                                                                <p className="font-semibold">{impostor.name}</p>
                                                                <p className="text-sm text-gray-600">
                                                                    {impostor.wins} victorias • {impostor.games} partidas
                                                                </p>
                                                            </div>
                                                        </div>
                                                        <div className="text-right">
                                                            <p className="text-xl font-bold">{impostor.points} pts</p>
                                                            <p className="text-xs text-gray-500">
                                                                {winRate}% efectividad
                                                            </p>
                                                        </div>
                                                    </div>
                                                );
                                            })}
                                        </div>
                                        <p className="text-xs text-gray-500 mt-2">
                                            * Puntos: +3 por ganar, 0 por perder
                                        </p>
                                    </div>
                                )}
                                
                                <div className="bg-blue-50 rounded-xl p-4 mb-6 flex items-center gap-2">
                                    <Icon type="mic" />
                                    <p className="text-sm text-gray-700">
                                        <strong>Tip:</strong> Usa Discord o llamada para hablar mientras juegan!
                                    </p>
                                </div>
                                
                                <div className="mb-6">
                                    <h3 className="text-xl font-semibold mb-3 flex items-center gap-2">
                                        <Icon type="users" />
                                        Jugadores ({players.length}/10)
                                    </h3>
                                    <div className="grid grid-cols-2 gap-3">
                                        {players.map(player => (
                                            <div key={player.id} className="bg-gray-50 rounded-lg p-3 flex items-center gap-2">
                                                {player.isHost && <Icon type="crown" size={16} />}
                                                {player.isBot && <Icon type="bot" size={14} />}
                                                <span className={`font-medium ${player.isBot ? 'text-gray-600' : ''}`}>
                                                    {player.name}
                                                </span>
                                            </div>
                                        ))}
                                    </div>
                                </div>
                                
                                {isHost && (
                                    <div className="space-y-4">
                                        <div>
                                            <label className="block text-sm font-medium mb-2">Categoría</label>
                                            <select 
                                                value={roomData?.config?.category || ''} 
                                                onChange={(e) => updateConfig({ category: e.target.value })}
                                                className="w-full px-4 py-3 border-2 border-gray-300 rounded-xl focus:border-purple-500 focus:outline-none"
                                            >
                                                <option value="">-- Selecciona --</option>
                                                {Object.keys(WORDS_DATABASE).map(cat => (
                                                    <option key={cat} value={cat}>
                                                        {cat.charAt(0).toUpperCase() + cat.slice(1)} ({WORDS_DATABASE[cat].words.length} palabras)
                                                    </option>
                                                ))}
                                            </select>
                                        </div>
                                        
                                        <div>
                                            <label className="block text-sm font-medium mb-2">
                                                Número de Impostores: {roomData?.config?.impostorCount || 1}
                                            </label>
                                            <input 
                                                type="range" 
                                                min="1" 
                                                max={Math.min(3, Math.floor(players.length / 2))} 
                                                value={roomData?.config?.impostorCount || 1} 
                                                onChange={(e) => updateConfig({ impostorCount: parseInt(e.target.value) })}
                                                className="w-full"
                                            />
                                        </div>
                                        
                                        <button 
                                            onClick={startGame} 
                                            disabled={players.length < 3 || !roomData?.config?.category}
                                            className="w-full bg-green-500 hover:bg-green-600 disabled:bg-gray-300 text-white font-semibold py-3 rounded-xl transition flex items-center justify-center gap-2"
                                        >
                                            <Icon type="play" />
                                            Iniciar Juego
                                        </button>
                                        
                                        <button 
                                            onClick={addBot} 
                                            disabled={players.length >= 10}
                                            className="w-full bg-gray-200 hover:bg-gray-300 disabled:bg-gray-100 text-gray-700 font-semibold py-2 rounded-lg transition flex items-center justify-center gap-2"
                                        >
                                            <Icon type="bot" size={16} />
                                            Agregar Bot
                                        </button>
                                    </div>
                                )}
                                
                                {!isHost && (
                                    <div className="text-center text-gray-600">
                                        Esperando a que el host inicie el juego...
                                    </div>
                                )}
                            </div>
                        </div>
                    </div>
                );
            }
            
            // Pantalla de juego (dando pistas) - MEJORADA
            if (gameStarted && gamePhase === 'playing') {
                const currentIndex = roomData?.game?.currentTurnIndex || 0;
                const currentPlayer = players[currentIndex % players.length];
                const isMyTurn = currentPlayer?.id === currentPlayerId;
                const currentRound = Math.floor(currentIndex / players.length) + 1;
                const word = roomData?.game?.word;
                const timerValue = roomData?.game?.timer;
                const isLastTurn = currentIndex >= (roomData?.game?.totalTurns || 0) - 1;
                
                return (
                    <div className="min-h-screen bg-gradient-to-br from-indigo-600 via-purple-500 to-pink-500 p-4">
                        <div className="max-w-4xl mx-auto">
                            {/* Notificación flotante */}
                            {notification && (
                                <div className="fixed top-4 right-4 bg-blue-500 text-white px-4 py-2 rounded-lg shadow-lg slide-up z-50">
                                    {notification}
                                </div>
                            )}
                            
                            <div className="bg-white rounded-3xl shadow-2xl p-8">
                                <div className="flex justify-between items-center mb-6">
                                    <div className="flex items-center gap-4">
                                        <div className="bg-purple-100 rounded-full px-4 py-2">
                                            <span className="font-bold text-purple-600">Ronda {currentRound}/3</span>
                                        </div>
                                        <div className="bg-green-100 rounded-full px-4 py-2">
                                            <span className="font-bold text-green-600">Turno {currentIndex + 1}/{roomData?.game?.totalTurns}</span>
                                        </div>
                                        {!currentPlayer?.isBot && timerValue !== null && timerValue !== undefined && (
                                            <div className={`rounded-full px-4 py-2 ${timerValue <= 10 ? 'bg-red-100 blink' : 'bg-blue-100'}`}>
                                                <span className={`font-bold ${timerValue <= 10 ? 'text-red-600 countdown-animation' : 'text-blue-600'}`}>
                                                    ⏱️ {timerValue}s
                                                </span>
                                            </div>
                                        )}
                                    </div>
                                    <button 
                                        onClick={toggleSound}
                                        className={`p-2 rounded-lg transition ${soundEnabled ? 'bg-green-100 text-green-700' : 'bg-gray-100 text-gray-700'}`}
                                        title={soundEnabled ? 'Desactivar sonidos' : 'Activar sonidos'}
                                    >
                                        <Icon type="volume" size={20} />
                                    </button>
                                </div>
                                
                                {/* Transición entre rondas */}
                                {roundTransition && (
                                    <div className="mb-6 bg-gradient-to-r from-purple-500 to-pink-500 rounded-xl p-6 text-center text-white fade-in">
                                        <h3 className="text-2xl font-bold mb-2">¡Fin de la ronda {currentRound}!</h3>
                                        <p className="text-lg mb-4">Preparando siguiente ronda...</p>
                                        <div className="flex items-center justify-center gap-3">
                                            <Icon type="clock" size={32} />
                                            <span className="text-4xl font-bold">{transitionCountdown}</span>
                                            <span className="text-lg">segundos</span>
                                        </div>
                                        <p className="text-sm opacity-80 mt-3">
                                            Todos pueden ver las pistas de esta ronda antes de continuar
                                        </p>
                                    </div>
                                )}
                                
                                {/* Área de palabra/impostor */}
                                <div className={`relative rounded-xl p-6 mb-6 transition-all duration-300 ${
                                    isImpostor ? 'bg-red-50 border-2 border-red-200' : 'bg-gradient-to-r from-yellow-100 to-orange-100'
                                }`}>
                                    {isImpostor ? (
                                        <div>
                                            {showImpostorAnimation ? (
                                                <div className="text-center">
                                                    <p className="impostor-bounce text-3xl font-bold text-red-600">
                                                        ¡ERES EL IMPOSTOR!
                                                    </p>
                                                    <p className="text-red-500 mt-2">Solo tú ves esto...</p>
                                                </div>
                                            ) : (
                                                <div>
                                                    <p className="text-sm text-gray-600 mb-2">Tu rol:</p>
                                                    <p className="text-2xl font-bold text-red-600">IMPOSTOR</p>
                                                    <p className="text-sm text-red-500 mt-2">
                                                        No sabes la palabra, solo la categoría: <span className="font-semibold">{CATEGORY_HINTS[roomData?.config?.category]}</span>
                                                    </p>
                                                    <div className="mt-3 p-2 bg-red-100 rounded-lg">
                                                        <p className="text-xs text-red-700">
                                                            <strong>Consejo:</strong> Da pistas que puedan aplicarse a muchas palabras de esta categoría
                                                        </p>
                                                    </div>
                                                </div>
                                            )}
                                        </div>
                                    ) : (
                                        <div>
                                            <div className="flex justify-between items-start mb-2">
                                                <p className="text-sm text-gray-600">Tu palabra:</p>
                                                <button 
                                                    onClick={toggleWordVisibility}
                                                    className="p-2 hover:bg-gray-200 rounded-lg transition"
                                                    title={showWord ? "Ocultar palabra" : "Mostrar palabra"}
                                                >
                                                    <Icon type={showWord ? "eyeOff" : "eye"} size={18} />
                                                </button>
                                            </div>
                                            
                                            <div className={`transition-all duration-300 ${showWord ? 'opacity-100' : 'opacity-30 blur-sm'}`}>
                                                {showWord ? (
                                                    <div>
                                                        <p className="text-3xl font-bold text-orange-600">{word}</p>
                                                        <div className="mt-2">
                                                            <p className="text-sm text-gray-600">Posibles pistas:</p>
                                                            <div className="flex flex-wrap gap-1 mt-1">
                                                                {(() => {
                                                                    const category = roomData?.config?.category;
                                                                    const categoryData = WORDS_DATABASE[category];
                                                                    if (categoryData && categoryData.clues && categoryData.clues[word]) {
                                                                        return categoryData.clues[word].slice(0, 5).map((clue, idx) => (
                                                                            <span key={idx} className="text-xs bg-blue-100 text-blue-800 px-2 py-1 rounded">
                                                                                {clue}
                                                                            </span>
                                                                        ));
                                                                    }
                                                                    return (
                                                                        <span className="text-xs text-gray-500">
                                                                            Busca sinónimos o características
                                                                        </span>
                                                                    );
                                                                })()}
                                                            </div>
                                                        </div>
                                                    </div>
                                                ) : (
                                                    <div className="text-center py-4">
                                                        <p className="text-lg text-gray-500 mb-2">La palabra está oculta</p>
                                                        <p className="text-sm text-gray-400">
                                                            Presiona el botón del ojo para verla
                                                        </p>
                                                    </div>
                                                )}
                                            </div>
                                            
                                            {!showWord && (
                                                <div className="mt-4 p-3 bg-blue-50 rounded-lg">
                                                    <p className="text-sm text-blue-700 flex items-center gap-2">
                                                        <Icon type="alert" size={16} />
                                                        <strong>Para streamers:</strong> La palabra se oculta automáticamente para evitar stream sniping
                                                    </p>
                                                </div>
                                            )}
                                        </div>
                                    )}
                                </div>
                                
                                <div className="bg-blue-50 rounded-xl p-4 mb-6">
                                    <p className="text-center font-semibold text-lg">
                                        Turno de: <span className="text-blue-600">{currentPlayer?.name}</span>
                                        {isLastTurn && !roundTransition && (
                                            <span className="ml-2 text-sm text-red-600 font-normal">
                                                (Último turno)
                                            </span>
                                        )}
                                    </p>
                                </div>
                                
                                {isMyTurn && !roundTransition ? (
                                    <div className="space-y-4">
                                        <input 
                                            type="text" 
                                            value={clueInput} 
                                            onChange={(e) => setClueInput(e.target.value)}
                                            onKeyPress={(e) => {
                                                if (e.key === 'Enter' && clueInput.trim()) {
                                                    submitClue(clueInput);
                                                    setClueInput('');
                                                }
                                            }}
                                            placeholder="Escribe tu pista (sinónimos, características)..."
                                            className="w-full px-4 py-3 border-2 border-gray-300 rounded-xl focus:border-purple-500 focus:outline-none text-lg"
                                            disabled={roundTransition}
                                        />
                                        <button 
                                            onClick={() => {
                                                submitClue(clueInput);
                                                setClueInput('');
                                            }}
                                            disabled={!clueInput.trim() || roundTransition}
                                            className="w-full bg-green-500 hover:bg-green-600 disabled:bg-gray-300 text-white font-semibold py-3 rounded-xl transition"
                                        >
                                            Enviar Pista
                                        </button>
                                        
                                        {timerValue !== null && timerValue !== undefined && (
                                            <div className="text-center">
                                                <p className="text-sm text-gray-600">
                                                    Tiempo restante: <span className={`font-bold ${timerValue <= 10 ? 'text-red-600' : 'text-blue-600'}`}>{timerValue}s</span>
                                                </p>
                                                {timerValue <= 10 && (
                                                    <p className="text-xs text-red-500 mt-1">¡Date prisa! Se acabará el tiempo</p>
                                                )}
                                            </div>
                                        )}
                                    </div>
                                ) : roundTransition ? (
                                    <div className="text-center text-gray-600 py-6">
                                        <p className="text-lg">Preparando siguiente ronda...</p>
                                        <p className="text-sm text-gray-500 mt-2">
                                            Espera {transitionCountdown} segundos
                                        </p>
                                    </div>
                                ) : (
                                    <div className="text-center text-gray-600 py-6">
                                        Esperando a que {currentPlayer?.name} dé su pista...
                                        {timerValue !== null && timerValue !== undefined && (
                                            <p className="text-sm mt-2">
                                                Tiempo restante: <span className="font-bold">{timerValue}s</span>
                                            </p>
                                        )}
                                    </div>
                                )}
                                
                                <div className="mt-8">
                                    <h3 className="text-xl font-semibold mb-4">Pistas de la ronda {currentRound}:</h3>
                                    <div className="space-y-2">
                                        {players.map(player => {
                                            const roundResponse = roomData?.game?.responses?.[player.id]?.[currentRound];
                                            return (
                                                <div key={player.id} className="flex items-center justify-between bg-gray-50 rounded-lg p-3">
                                                    <span className="font-medium">{player.name}</span>
                                                    <span className="text-gray-600">{roundResponse?.clue || '...'}</span>
                                                </div>
                                            );
                                        })}
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                );
            }
            
            // Pantalla de votación
            if (gamePhase === 'voting') {
                const votes = roomData?.game?.votes || {};
                const hasVoted = votes[currentPlayerId];
                const allVoted = Object.keys(votes).length === players.length;
                
                const voteCount = {};
                Object.values(votes).forEach(votedId => {
                    voteCount[votedId] = (voteCount[votedId] || 0) + 1;
                });
                
                return (
                    <div className="min-h-screen bg-gradient-to-br from-orange-600 via-red-500 to-pink-500 p-4">
                        <div className="max-w-4xl mx-auto">
                            {/* Notificación flotante */}
                            {notification && (
                                <div className="fixed top-4 right-4 bg-blue-500 text-white px-4 py-2 rounded-lg shadow-lg slide-up z-50">
                                    {notification}
                                </div>
                            )}
                            
                            <div className="bg-white rounded-3xl shadow-2xl p-8">
                                <h2 className="text-3xl font-bold text-center mb-6 flex items-center justify-center gap-2">
                                    <Icon type="vote" size={32} />
                                    Fase de Votación
                                </h2>
                                
                                <p className="text-center text-gray-600 mb-6">
                                    ¡Es hora de votar! ¿Quién crees que es el impostor?
                                </p>
                                
                                {/* Mensaje de error */}
                                {votingError && (
                                    <div className={`mb-4 p-3 rounded-lg ${votingError.includes('Error') ? 'bg-red-100 text-red-700' : 'bg-yellow-100 text-yellow-700'} shake`}>
                                        <p className="flex items-center gap-2">
                                            <Icon type="alert" size={16} />
                                            {votingError}
                                        </p>
                                    </div>
                                )}
                                
                                {/* Contador de votos */}
                                <div className="mb-6 bg-blue-50 rounded-xl p-4">
                                    <p className="text-center font-medium text-lg">
                                        Votos: <span className="font-bold">{Object.keys(votes).length}</span> / <span className="font-bold">{players.length}</span>
                                    </p>
                                    <p className="text-center text-sm text-gray-600 mt-1">
                                        {allVoted ? '¡Todos han votado!' : 'Esperando votos...'}
                                    </p>
                                </div>
                                
                                <div className="grid grid-cols-2 gap-4 mb-6">
                                    {players.map(player => (
                                        <button 
                                            key={player.id} 
                                            onClick={() => submitVote(player.id)}
                                            disabled={hasVoted || player.id === currentPlayerId}
                                            className={`p-4 rounded-xl font-semibold transition ${
                                                votes[currentPlayerId] === player.id ? 'bg-red-500 text-white' : 
                                                player.id === currentPlayerId ? 'bg-gray-200 text-gray-400' : 
                                                'bg-gray-100 hover:bg-red-100'
                                            }`}
                                        >
                                            <div className="flex items-center justify-between">
                                                <span>{player.name}</span>
                                                <span className="text-sm font-bold ml-2">
                                                    {voteCount[player.id] ? `(${voteCount[player.id]})` : ''}
                                                </span>
                                            </div>
                                            {votes[currentPlayerId] === player.id && (
                                                <span className="text-xs">✓ Votado</span>
                                            )}
                                        </button>
                                    ))}
                                </div>
                                
                                {isHost && (
                                    <div className="space-y-3">
                                        <button 
                                            onClick={finishVoting}
                                            disabled={!allVoted}
                                            className={`w-full ${allVoted ? 'bg-green-500 hover:bg-green-600' : 'bg-gray-300'} text-white font-semibold py-3 rounded-xl transition`}
                                        >
                                            {allVoted ? 'Terminar Votación' : 'Esperando votos...'}
                                        </button>
                                        
                                        {!allVoted && (
                                            <div className="text-center text-sm text-gray-500">
                                                El botón se activará cuando todos hayan votado
                                            </div>
                                        )}
                                    </div>
                                )}
                                
                                {!isHost && !hasVoted && (
                                    <div className="text-center text-gray-600 py-4">
                                        ¡Vota por quién crees que es el impostor!
                                    </div>
                                )}
                                
                                {!isHost && hasVoted && (
                                    <div className="text-center text-gray-600 py-4">
                                        Has votado. Esperando a que los demás voten...
                                    </div>
                                )}
                            </div>
                        </div>
                    </div>
                );
            }
            
            // Pantalla de resultados
            if (gamePhase === 'finished') {
                const impostorIds = roomData?.game?.impostorIds || [];
                const winner = roomData?.game?.winner;
                const word = roomData?.game?.word;
                const roomStats = roomData?.roomStats || { gamesPlayed: 0, impostorWins: 0, playerWins: 0 };
                
                return (
                    <div className="min-h-screen bg-gradient-to-br from-green-600 via-blue-500 to-purple-500 p-4">
                        <div className="max-w-4xl mx-auto">
                            {/* Notificación flotante */}
                            {notification && (
                                <div className="fixed top-4 right-4 bg-blue-500 text-white px-4 py-2 rounded-lg shadow-lg slide-up z-50">
                                    {notification}
                                </div>
                            )}
                            
                            <div className="bg-white rounded-3xl shadow-2xl p-8">
                                <h2 className="text-4xl font-bold text-center mb-6 fade-in">
                                    {winner === 'players' ? '🎉 ¡Ganaron los Jugadores!' : '😈 ¡Ganaron los Impostores!'}
                                </h2>
                                
                                <div className="bg-gradient-to-r from-yellow-100 to-orange-100 rounded-xl p-6 mb-6 fade-in">
                                    <p className="text-lg mb-2">
                                        <strong>La palabra era:</strong> <span className="text-2xl font-bold text-orange-600">{word}</span>
                                    </p>
                                    <p className="text-lg">
                                        <strong>El/Los impostor(es):</strong>
                                        {impostorIds.map((id, idx) => {
                                            const impostor = players.find(p => p.id === id);
                                            return (
                                                <span key={id} className="text-xl font-semibold text-red-600 ml-2">
                                                    {idx > 0 && ', '} {impostor?.name}
                                                </span>
                                            );
                                        })}
                                    </p>
                                </div>
                                
                                {/* TOP 3 actualizado con nueva lógica */}
                                {topImpostors.length > 0 && (
                                    <div className="mb-6 bg-gradient-to-r from-yellow-50 to-orange-50 rounded-xl p-4 slide-in">
                                        <h3 className="text-lg font-semibold mb-3 flex items-center gap-2">
                                            <Icon type="trophy" size={20} />
                                            TOP 3 Mejores Impostores
                                        </h3>
                                        <div className="space-y-3">
                                            {topImpostors.map((impostor, index) => {
                                                const winRate = impostor.games > 0 ? Math.round((impostor.wins / impostor.games) * 100) : 0;
                                                return (
                                                    <div key={impostor.id} className={`p-3 rounded-lg flex items-center justify-between ${index === 0 ? 'rank-1' : index === 1 ? 'rank-2' : 'rank-3'}`}>
                                                        <div className="flex items-center gap-3">
                                                            <span className={`text-2xl font-bold ${index === 0 ? 'trophy-gold' : index === 1 ? 'trophy-silver' : 'trophy-bronze'}`}>
                                                                {index === 0 ? '🥇' : index === 1 ? '🥈' : '🥉'}
                                                            </span>
                                                            <div>
                                                                <p className="font-semibold">{impostor.name}</p>
                                                                <p className="text-sm text-gray-600">
                                                                    {impostor.wins}/{impostor.games} victorias ({winRate}%)
                                                                </p>
                                                            </div>
                                                        </div>
                                                        <div className="text-right">
                                                            <p className="text-xl font-bold">{impostor.points} pts</p>
                                                            <p className="text-xs text-gray-500">
                                                                {index === 0 ? '🥇 Mejor mentiroso' : index === 1 ? '🥈 Gran impostor' : '🥉 Buen impostor'}
                                                            </p>
                                                        </div>
                                                    </div>
                                                );
                                            })}
                                        </div>
                                        <p className="text-xs text-gray-500 mt-2">
                                            * Puntos: +3 por ganar (no ser descubierto), 0 por perder
                                        </p>
                                    </div>
                                )}
                                
                                <div className="mb-6 max-h-96 overflow-y-auto">
                                    <h3 className="text-xl font-semibold mb-3">Historial de pistas:</h3>
                                    {players.map(player => {
                                        const responses = roomData?.game?.responses?.[player.id] || {};
                                        const isImpostorPlayer = impostorIds.includes(player.id);
                                        
                                        return (
                                            <div key={player.id} className="mb-4 bg-gray-50 rounded-lg p-4">
                                                <p className="font-semibold mb-2 flex items-center gap-2">
                                                    {player.name}
                                                    {isImpostorPlayer && (
                                                        <span className="text-xs bg-red-500 text-white px-2 py-1 rounded">
                                                            IMPOSTOR
                                                        </span>
                                                    )}
                                                </p>
                                                <div className="space-y-1">
                                                    {Object.entries(responses).map(([round, data]) => (
                                                        <p key={round} className="text-sm text-gray-700">
                                                            Ronda {round}: <span className="font-medium">{data.clue}</span>
                                                        </p>
                                                    ))}
                                                </div>
                                            </div>
                                        );
                                    })}
                                </div>
                                
                                {isHost && (
                                    <div className="flex gap-3">
                                        <button 
                                            onClick={startNewGame}
                                            className="flex-1 bg-green-500 hover:bg-green-600 text-white font-semibold py-3 rounded-xl transition flex items-center justify-center gap-2"
                                        >
                                            <Icon type="refresh" size={20} />
                                            Nueva Partida
                                        </button>
                                        <button 
                                            onClick={resetGame}
                                            className="flex-1 bg-blue-500 hover:bg-blue-600 text-white font-semibold py-3 rounded-xl transition flex items-center justify-center gap-2"
                                        >
                                            <Icon type="home" size={20} />
                                            Reiniciar Sala
                                        </button>
                                        <button 
                                            onClick={goHome}
                                            className="flex-1 bg-gray-500 hover:bg-gray-600 text-white font-semibold py-3 rounded-xl transition"
                                        >
                                            Salir
                                        </button>
                                    </div>
                                )}
                                
                                {!isHost && (
                                    <div className="text-center text-gray-600">
                                        Esperando a que el host inicie una nueva partida...
                                    </div>
                                )}
                            </div>
                        </div>
                    </div>
                );
            }
            
            return null;
        }

        // Renderizar la aplicación
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<ImpostorGame />);
    </script>
</body>
</html>